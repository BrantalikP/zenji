/**
 * Generated by @openapi-codegen
 *
 * @version 20170710.0
 */
import * as reactQuery from '@tanstack/react-query'

import { useContext, Context } from './context'
import type * as Fetcher from './fetcher'
import { fetch } from './fetcher'
import type * as Responses from './responses'
import type * as Schemas from './schemas'

export type GetAssignmentsQueryParams = {
  /**
   * Only assignments available at or after this time are returned.
   *
   * @format date-time
   */
  available_after?: string
  /**
   * Only assignments available at or before this time are returned.
   *
   * @format date-time
   */
  available_before?: string
  /**
   * When set to true, returns assignments that have a value in data.burned_at. Returns assignments with a null data.burned_at if false.
   */
  burned?: boolean
  /**
   * Return assignments with a matching value in the hidden attribute
   */
  hidden?: boolean
  /**
   * Only assignments where data.id matches one of the array values are returned.
   */
  ids?: number[]
  /**
   * Returns assignments which are immediately available for lessons
   */
  immediately_available_for_lessons?: boolean
  /**
   * Returns assignments which are immediately available for review
   */
  immediately_available_for_review?: boolean
  /**
   * Returns assignments which are in the review state
   */
  in_review?: boolean
  /**
   * Only assignments where the associated subject level matches one of the array values are returned. Valid values range from 1 to 60.
   */
  levels?: number[]
  /**
   * Only assignments where data.srs_stage matches one of the array values are returned. Valid values range from 0 to 9
   */
  srs_stages?: number[]
  /**
   * When set to true, returns assignments that have a value in data.started_at. Returns assignments with a null data.started_at if false.
   */
  started?: boolean
  /**
   * Only assignments where data.subject_id matches one of the array values are returned.
   */
  subject_ids?: number[]
  /**
   * Only assignments where data.subject_type matches one of the array values are returned. Valid values are: radical, kanji, or vocabulary.
   */
  subject_types?: Schemas.SubjectType[]
  /**
   * When set to true, returns assignments that have a value in data.unlocked_at. Returns assignments with a null data.unlocked_at if false.
   */
  unlocked?: boolean
  /**
   * Only assignments updated after this time are returned.
   *
   * @format date-time
   */
  updated_after?: string
}

export type GetAssignmentsError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetAssignmentsVariables = {
  queryParams?: GetAssignmentsQueryParams
} & Context['fetcherOptions']

/**
 * Returns a collection of all assignments, ordered by ascending created_at, 500 at a time.
 */
export const fetchGetAssignments = (variables: GetAssignmentsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.Assignments,
    GetAssignmentsError,
    undefined,
    object,
    GetAssignmentsQueryParams,
    object
  >({
    url: '/assignments',
    method: 'get',
    ...variables,
    signal,
  })

/**
 * Returns a collection of all assignments, ordered by ascending created_at, 500 at a time.
 */
export const useGetAssignments = <TData = Schemas.Assignments>(
  variables: GetAssignmentsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Assignments, GetAssignmentsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.Assignments, GetAssignmentsError, TData>({
    queryKey: queryKeyFn({ path: '/assignments', operationId: 'getAssignments', variables }),
    queryFn: ({ signal }) => fetchGetAssignments({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetAssignmentPathParams = {
  /**
   * ID of the resource
   */
  id: number
}

export type GetAssignmentError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetAssignmentVariables = {
  pathParams: GetAssignmentPathParams
} & Context['fetcherOptions']

/**
 * Retrieves a specific assignment by its id.
 */
export const fetchGetAssignment = (variables: GetAssignmentVariables, signal?: AbortSignal) =>
  fetch<Schemas.Assignment, GetAssignmentError, undefined, object, object, GetAssignmentPathParams>(
    {
      url: '/assignments/{id}',
      method: 'get',
      ...variables,
      signal,
    },
  )

/**
 * Retrieves a specific assignment by its id.
 */
export const useGetAssignment = <TData = Schemas.Assignment>(
  variables: GetAssignmentVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Assignment, GetAssignmentError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.Assignment, GetAssignmentError, TData>({
    queryKey: queryKeyFn({ path: '/assignments/{id}', operationId: 'getAssignment', variables }),
    queryFn: ({ signal }) => fetchGetAssignment({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type StartAssignmentPathParams = {
  /**
   * ID of the resource
   */
  id: number
}

export type StartAssignmentError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type StartAssignmentVariables = {
  body?: Schemas.StartAssignmentRequest
  pathParams: StartAssignmentPathParams
} & Context['fetcherOptions']

/**
 * Mark the assignment as started, moving the assignment from the lessons queue to the review queue. Returns the updated assignment.
 */
export const fetchStartAssignment = (variables: StartAssignmentVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.Assignment,
    StartAssignmentError,
    Schemas.StartAssignmentRequest,
    object,
    object,
    StartAssignmentPathParams
  >({ url: '/assignments/{id}/start', method: 'put', ...variables, signal })

/**
 * Mark the assignment as started, moving the assignment from the lessons queue to the review queue. Returns the updated assignment.
 */
export const useStartAssignment = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Assignment,
      StartAssignmentError,
      StartAssignmentVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useContext()
  return reactQuery.useMutation<Schemas.Assignment, StartAssignmentError, StartAssignmentVariables>(
    {
      mutationFn: (variables: StartAssignmentVariables) =>
        fetchStartAssignment({ ...fetcherOptions, ...variables }),
      ...options,
    },
  )
}

export type GetLevelProgressionsQueryParams = {
  /**
   * Only level progressions where data.id matches one of the array values are returned.
   */
  ids?: number[]
  /**
   * Only level_progressions updated after this time are returned.
   *
   * @format date-time
   */
  updated_after?: string
}

export type GetLevelProgressionsError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetLevelProgressionsVariables = {
  queryParams?: GetLevelProgressionsQueryParams
} & Context['fetcherOptions']

/**
 * Returns a collection of all level progressions, ordered by ascending created_at, 500 at a time.
 */
export const fetchGetLevelProgressions = (
  variables: GetLevelProgressionsVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.LevelProgressions,
    GetLevelProgressionsError,
    undefined,
    object,
    GetLevelProgressionsQueryParams,
    object
  >({ url: '/level_progressions', method: 'get', ...variables, signal })

/**
 * Returns a collection of all level progressions, ordered by ascending created_at, 500 at a time.
 */
export const useGetLevelProgressions = <TData = Schemas.LevelProgressions>(
  variables: GetLevelProgressionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.LevelProgressions, GetLevelProgressionsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.LevelProgressions, GetLevelProgressionsError, TData>({
    queryKey: queryKeyFn({
      path: '/level_progressions',
      operationId: 'getLevelProgressions',
      variables,
    }),
    queryFn: ({ signal }) => fetchGetLevelProgressions({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetLevelProgressionPathParams = {
  /**
   * ID of the resource
   */
  id: number
}

export type GetLevelProgressionError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetLevelProgressionVariables = {
  pathParams: GetLevelProgressionPathParams
} & Context['fetcherOptions']

/**
 * Retrieves a specific level progression by its id.
 */
export const fetchGetLevelProgression = (
  variables: GetLevelProgressionVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.LevelProgression,
    GetLevelProgressionError,
    undefined,
    object,
    object,
    GetLevelProgressionPathParams
  >({ url: '/level_progressions/{id}', method: 'get', ...variables, signal })

/**
 * Retrieves a specific level progression by its id.
 */
export const useGetLevelProgression = <TData = Schemas.LevelProgression>(
  variables: GetLevelProgressionVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.LevelProgression, GetLevelProgressionError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.LevelProgression, GetLevelProgressionError, TData>({
    queryKey: queryKeyFn({
      path: '/level_progressions/{id}',
      operationId: 'getLevelProgression',
      variables,
    }),
    queryFn: ({ signal }) => fetchGetLevelProgression({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetResetsQueryParams = {
  /**
   * Only resets where data.id matches one of the array values are returned.
   */
  ids?: number[]
  /**
   * Only resets updated after this time are returned.
   *
   * @format date-time
   */
  updated_after?: string
}

export type GetResetsError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetResetsVariables = {
  queryParams?: GetResetsQueryParams
} & Context['fetcherOptions']

/**
 * Returns a collection of all resets, ordered by ascending created_at, 500 at a time.
 */
export const fetchGetResets = (variables: GetResetsVariables, signal?: AbortSignal) =>
  fetch<Schemas.Resets, GetResetsError, undefined, object, GetResetsQueryParams, object>({
    url: '/resets',
    method: 'get',
    ...variables,
    signal,
  })

/**
 * Returns a collection of all resets, ordered by ascending created_at, 500 at a time.
 */
export const useGetResets = <TData = Schemas.Resets>(
  variables: GetResetsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Resets, GetResetsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.Resets, GetResetsError, TData>({
    queryKey: queryKeyFn({ path: '/resets', operationId: 'getResets', variables }),
    queryFn: ({ signal }) => fetchGetResets({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetResetPathParams = {
  /**
   * ID of the resource
   */
  id: number
}

export type GetResetError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetResetVariables = {
  pathParams: GetResetPathParams
} & Context['fetcherOptions']

/**
 * Retrieves a specific reset by its id.
 */
export const fetchGetReset = (variables: GetResetVariables, signal?: AbortSignal) =>
  fetch<Schemas.Reset, GetResetError, undefined, object, object, GetResetPathParams>({
    url: '/resets/{id}',
    method: 'get',
    ...variables,
    signal,
  })

/**
 * Retrieves a specific reset by its id.
 */
export const useGetReset = <TData = Schemas.Reset>(
  variables: GetResetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Reset, GetResetError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.Reset, GetResetError, TData>({
    queryKey: queryKeyFn({ path: '/resets/{id}', operationId: 'getReset', variables }),
    queryFn: ({ signal }) => fetchGetReset({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetReviewsQueryParams = {
  /**
   * Only reviews where data.id matches one of the array values are returned.
   */
  ids?: number[]
  /**
   * Only reviews updated after this time are returned.
   *
   * @format date-time
   */
  updated_after?: string
  /**
   * Only reviews where data.assignment_id matches one of the array values are returned.
   */
  assignment_ids?: number[]
  /**
   * Only reviews where data.subject_id matches one of the array values are returned.
   */
  subject_ids?: number[]
}

export type GetReviewsError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetReviewsVariables = {
  queryParams?: GetReviewsQueryParams
} & Context['fetcherOptions']

/**
 * Returns a collection of all reviews, ordered by ascending created_at, 500 at a time.
 */
export const fetchGetReviews = (variables: GetReviewsVariables, signal?: AbortSignal) =>
  fetch<Schemas.Reviews, GetReviewsError, undefined, object, GetReviewsQueryParams, object>({
    url: '/reviews',
    method: 'get',
    ...variables,
    signal,
  })

/**
 * Returns a collection of all reviews, ordered by ascending created_at, 500 at a time.
 */
export const useGetReviews = <TData = Schemas.Reviews>(
  variables: GetReviewsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Reviews, GetReviewsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.Reviews, GetReviewsError, TData>({
    queryKey: queryKeyFn({ path: '/reviews', operationId: 'getReviews', variables }),
    queryFn: ({ signal }) => fetchGetReviews({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type CreateReviewError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type CreateReviewVariables = {
  body?: Schemas.CreateReviewRequest
} & Context['fetcherOptions']

/**
 * Creates a review for a specific assignment_id. Using the related subject_id is also a valid alternative to using assignment_id.
 *
 * Some criteria must be met in order for a review to be created: available_at must be not null and in the past.
 *
 * When a review is registered, the associated assignment and review_statistic are both updated. These are returned in the response body under resources_updated.
 */
export const fetchCreateReview = (variables: CreateReviewVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.CreateReviewResponse,
    CreateReviewError,
    Schemas.CreateReviewRequest,
    object,
    object,
    object
  >({
    url: '/reviews',
    method: 'post',
    ...variables,
    signal,
  })

/**
 * Creates a review for a specific assignment_id. Using the related subject_id is also a valid alternative to using assignment_id.
 *
 * Some criteria must be met in order for a review to be created: available_at must be not null and in the past.
 *
 * When a review is registered, the associated assignment and review_statistic are both updated. These are returned in the response body under resources_updated.
 */
export const useCreateReview = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CreateReviewResponse,
      CreateReviewError,
      CreateReviewVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useContext()
  return reactQuery.useMutation<
    Schemas.CreateReviewResponse,
    CreateReviewError,
    CreateReviewVariables
  >({
    mutationFn: (variables: CreateReviewVariables) =>
      fetchCreateReview({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type GetReviewPathParams = {
  /**
   * ID of the resource
   */
  id: number
}

export type GetReviewError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetReviewVariables = {
  pathParams: GetReviewPathParams
} & Context['fetcherOptions']

/**
 * Retrieves a specific review by its id.
 */
export const fetchGetReview = (variables: GetReviewVariables, signal?: AbortSignal) =>
  fetch<Schemas.Review, GetReviewError, undefined, object, object, GetReviewPathParams>({
    url: '/reviews/{id}',
    method: 'get',
    ...variables,
    signal,
  })

/**
 * Retrieves a specific review by its id.
 */
export const useGetReview = <TData = Schemas.Review>(
  variables: GetReviewVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Review, GetReviewError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.Review, GetReviewError, TData>({
    queryKey: queryKeyFn({ path: '/reviews/{id}', operationId: 'getReview', variables }),
    queryFn: ({ signal }) => fetchGetReview({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetReviewStatisticsQueryParams = {
  /**
   * Only reviews where data.id matches one of the array values are returned.
   */
  ids?: number[]
  /**
   * Only reviews updated after this time are returned.
   *
   * @format date-time
   */
  updated_after?: string
  /**
   * Return review statistics with a matching value in the hidden attribute
   */
  hidden?: boolean
  /**
   * Only reviews where data.subject_id matches one of the array values are returned.
   */
  subject_ids?: number[]
  /**
   * Only review statistics where data.subject_type matches one of the array values are returned. Valid values are: radical, kanji, or vocabulary.
   */
  subject_types?: Schemas.SubjectType[]
  /**
   * Return review statistics where the percentage_correct is greater than the value.
   */
  percentages_greater_than?: number
  /**
   * Return review statistics where the percentage_correct is less than the value.
   */
  percentages_less_than?: number
}

export type GetReviewStatisticsError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetReviewStatisticsVariables = {
  queryParams?: GetReviewStatisticsQueryParams
} & Context['fetcherOptions']

/**
 * Returns a collection of all review statistics, ordered by ascending created_at, 500 at a time.
 */
export const fetchGetReviewStatistics = (
  variables: GetReviewStatisticsVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.ReviewStatistics,
    GetReviewStatisticsError,
    undefined,
    object,
    GetReviewStatisticsQueryParams,
    object
  >({ url: '/review_statistics', method: 'get', ...variables, signal })

/**
 * Returns a collection of all review statistics, ordered by ascending created_at, 500 at a time.
 */
export const useGetReviewStatistics = <TData = Schemas.ReviewStatistics>(
  variables: GetReviewStatisticsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ReviewStatistics, GetReviewStatisticsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.ReviewStatistics, GetReviewStatisticsError, TData>({
    queryKey: queryKeyFn({
      path: '/review_statistics',
      operationId: 'getReviewStatistics',
      variables,
    }),
    queryFn: ({ signal }) => fetchGetReviewStatistics({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetReviewStatisticPathParams = {
  /**
   * ID of the resource
   */
  id: number
}

export type GetReviewStatisticError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetReviewStatisticVariables = {
  pathParams: GetReviewStatisticPathParams
} & Context['fetcherOptions']

/**
 * Retrieves a specific review statistic by its id.
 */
export const fetchGetReviewStatistic = (
  variables: GetReviewStatisticVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.ReviewStatistic,
    GetReviewStatisticError,
    undefined,
    object,
    object,
    GetReviewStatisticPathParams
  >({ url: '/review_statistics/{id}', method: 'get', ...variables, signal })

/**
 * Retrieves a specific review statistic by its id.
 */
export const useGetReviewStatistic = <TData = Schemas.ReviewStatistic>(
  variables: GetReviewStatisticVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ReviewStatistic, GetReviewStatisticError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.ReviewStatistic, GetReviewStatisticError, TData>({
    queryKey: queryKeyFn({
      path: '/review_statistics/{id}',
      operationId: 'getReviewStatistic',
      variables,
    }),
    queryFn: ({ signal }) => fetchGetReviewStatistic({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetSpacedRepetitionSystemsQueryParams = {
  /**
   * Return study materials with a matching value in the hidden attribute
   */
  hidden?: boolean
  /**
   * Only study material records where data.id matches one of the array values are returned.
   */
  ids?: number[]
  /**
   * Only study material records updated after this time are returned.
   *
   * @format date-time
   */
  updated_after?: string
  /**
   * Only study material records where data.subject_id matches one of the array values are returned.
   */
  subject_ids?: number[]
  /**
   * Only study material records where data.subject_type matches one of the array values are returned. Valid values are: radical, kanji, or vocabulary.
   */
  subject_types?: Schemas.SubjectType[]
}

export type GetSpacedRepetitionSystemsError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetSpacedRepetitionSystemsVariables = {
  queryParams?: GetSpacedRepetitionSystemsQueryParams
} & Context['fetcherOptions']

/**
 * Returns a collection of all spaced repetition systems, ordered by ascending created_at, 500 at a time.
 */
export const fetchGetSpacedRepetitionSystems = (
  variables: GetSpacedRepetitionSystemsVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.SpacedRepetitionSystems,
    GetSpacedRepetitionSystemsError,
    undefined,
    object,
    GetSpacedRepetitionSystemsQueryParams,
    object
  >({ url: '/spaced_repetition_systems', method: 'get', ...variables, signal })

/**
 * Returns a collection of all spaced repetition systems, ordered by ascending created_at, 500 at a time.
 */
export const useGetSpacedRepetitionSystems = <TData = Schemas.SpacedRepetitionSystems>(
  variables: GetSpacedRepetitionSystemsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SpacedRepetitionSystems,
      GetSpacedRepetitionSystemsError,
      TData
    >,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<
    Schemas.SpacedRepetitionSystems,
    GetSpacedRepetitionSystemsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/spaced_repetition_systems',
      operationId: 'getSpacedRepetitionSystems',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetSpacedRepetitionSystems({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetSpacedRepetitionSystemPathParams = {
  /**
   * ID of the resource
   */
  id: number
}

export type GetSpacedRepetitionSystemError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetSpacedRepetitionSystemVariables = {
  pathParams: GetSpacedRepetitionSystemPathParams
} & Context['fetcherOptions']

/**
 * Retrieves a specific spaced repetition system by its id.
 */
export const fetchGetSpacedRepetitionSystem = (
  variables: GetSpacedRepetitionSystemVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.SpacedRepetitionSystem,
    GetSpacedRepetitionSystemError,
    undefined,
    object,
    object,
    GetSpacedRepetitionSystemPathParams
  >({ url: '/spaced_repetition_systems/{id}', method: 'get', ...variables, signal })

/**
 * Retrieves a specific spaced repetition system by its id.
 */
export const useGetSpacedRepetitionSystem = <TData = Schemas.SpacedRepetitionSystem>(
  variables: GetSpacedRepetitionSystemVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SpacedRepetitionSystem,
      GetSpacedRepetitionSystemError,
      TData
    >,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.SpacedRepetitionSystem, GetSpacedRepetitionSystemError, TData>(
    {
      queryKey: queryKeyFn({
        path: '/spaced_repetition_systems/{id}',
        operationId: 'getSpacedRepetitionSystem',
        variables,
      }),
      queryFn: ({ signal }) =>
        fetchGetSpacedRepetitionSystem({ ...fetcherOptions, ...variables }, signal),
      ...options,
      ...queryOptions,
    },
  )
}

export type GetStudyMaterialsQueryParams = {
  /**
   * Only spaced_repetition_systems where data.id matches one of the array values are returned.
   */
  ids?: number[]
  /**
   * Only spaced_repetition_systems updated after this time are returned.
   *
   * @format date-time
   */
  updated_after?: string
}

export type GetStudyMaterialsError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetStudyMaterialsVariables = {
  queryParams?: GetStudyMaterialsQueryParams
} & Context['fetcherOptions']

/**
 * Returns a collection of all study material, ordered by ascending created_at, 500 at a time.
 */
export const fetchGetStudyMaterials = (
  variables: GetStudyMaterialsVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.StudyMaterials,
    GetStudyMaterialsError,
    undefined,
    object,
    GetStudyMaterialsQueryParams,
    object
  >({ url: '/study_materials', method: 'get', ...variables, signal })

/**
 * Returns a collection of all study material, ordered by ascending created_at, 500 at a time.
 */
export const useGetStudyMaterials = <TData = Schemas.StudyMaterials>(
  variables: GetStudyMaterialsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StudyMaterials, GetStudyMaterialsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.StudyMaterials, GetStudyMaterialsError, TData>({
    queryKey: queryKeyFn({ path: '/study_materials', operationId: 'getStudyMaterials', variables }),
    queryFn: ({ signal }) => fetchGetStudyMaterials({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetStudyMaterialPathParams = {
  /**
   * ID of the resource
   */
  id: number
}

export type GetStudyMaterialError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetStudyMaterialVariables = {
  pathParams: GetStudyMaterialPathParams
} & Context['fetcherOptions']

/**
 * Retrieves a specific study material by its id.
 */
export const fetchGetStudyMaterial = (variables: GetStudyMaterialVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.StudyMaterial,
    GetStudyMaterialError,
    undefined,
    object,
    object,
    GetStudyMaterialPathParams
  >({ url: '/study_materials/{id}', method: 'get', ...variables, signal })

/**
 * Retrieves a specific study material by its id.
 */
export const useGetStudyMaterial = <TData = Schemas.StudyMaterial>(
  variables: GetStudyMaterialVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StudyMaterial, GetStudyMaterialError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.StudyMaterial, GetStudyMaterialError, TData>({
    queryKey: queryKeyFn({
      path: '/study_materials/{id}',
      operationId: 'getStudyMaterial',
      variables,
    }),
    queryFn: ({ signal }) => fetchGetStudyMaterial({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetSubjectsQueryParams = {
  /**
   * Only subjects where data.id matches one of the array values are returned.
   */
  ids?: number[]
  /**
   * Return subjects of the specified types.
   */
  types?: Schemas.SubjectType[]
  /**
   * Return subjects of the specified slug.
   */
  slugs?: string[]
  /**
   * Return subjects at the specified levels.
   */
  levels?: number[]
  /**
   * Return subjects which are or are not hidden from the user-facing application.
   */
  hidden?: boolean
  /**
   * Only subjects updated after this time are returned.
   *
   * @format date-time
   */
  updated_after?: string
}

export type GetSubjectsError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetSubjectsVariables = {
  queryParams?: GetSubjectsQueryParams
} & Context['fetcherOptions']

/**
 * Returns a collection of all subjects, ordered by ascending created_at, 500 at a time.
 */
export const fetchGetSubjects = (variables: GetSubjectsVariables, signal?: AbortSignal) =>
  fetch<Schemas.Subjects, GetSubjectsError, undefined, object, GetSubjectsQueryParams, object>({
    url: '/subjects',
    method: 'get',
    ...variables,
    signal,
  })

/**
 * Returns a collection of all subjects, ordered by ascending created_at, 500 at a time.
 */
export const useGetSubjects = <TData = Schemas.Subjects>(
  variables: GetSubjectsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Subjects, GetSubjectsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.Subjects, GetSubjectsError, TData>({
    queryKey: queryKeyFn({ path: '/subjects', operationId: 'getSubjects', variables }),
    queryFn: ({ signal }) => fetchGetSubjects({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetSubjectPathParams = {
  /**
   * ID of the resource
   */
  id: number
}

export type GetSubjectError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetSubjectVariables = {
  pathParams: GetSubjectPathParams
} & Context['fetcherOptions']

/**
 * Retrieves a specific subject by its id. The structure of the response depends on the subject type. See the section on subject data structure for details.
 */
export const fetchGetSubject = (variables: GetSubjectVariables, signal?: AbortSignal) =>
  fetch<Schemas.Subject, GetSubjectError, undefined, object, object, GetSubjectPathParams>({
    url: '/subjects/{id}',
    method: 'get',
    ...variables,
    signal,
  })

/**
 * Retrieves a specific subject by its id. The structure of the response depends on the subject type. See the section on subject data structure for details.
 */
export const useGetSubject = <TData = Schemas.Subject>(
  variables: GetSubjectVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Subject, GetSubjectError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.Subject, GetSubjectError, TData>({
    queryKey: queryKeyFn({ path: '/subjects/{id}', operationId: 'getSubject', variables }),
    queryFn: ({ signal }) => fetchGetSubject({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetSummaryError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetSummaryVariables = Context['fetcherOptions']

/**
 * Retrieves a summary report.
 */
export const fetchGetSummary = (variables: GetSummaryVariables, signal?: AbortSignal) =>
  fetch<Schemas.Summary, GetSummaryError, undefined, object, object, object>({
    url: '/summary',
    method: 'get',
    ...variables,
    signal,
  })

/**
 * Retrieves a summary report.
 */
export const useGetSummary = <TData = Schemas.Summary>(
  variables: GetSummaryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Summary, GetSummaryError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.Summary, GetSummaryError, TData>({
    queryKey: queryKeyFn({ path: '/summary', operationId: 'getSummary', variables }),
    queryFn: ({ signal }) => fetchGetSummary({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetUserError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetUserVariables = Context['fetcherOptions']

/**
 * Returns a summary of user information.
 */
export const fetchGetUser = (variables: GetUserVariables, signal?: AbortSignal) =>
  fetch<Schemas.User, GetUserError, undefined, object, object, object>({
    url: '/user',
    method: 'get',
    ...variables,
    signal,
  })

/**
 * Returns a summary of user information.
 */
export const useGetUser = <TData = Schemas.User>(
  variables: GetUserVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.User, GetUserError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.User, GetUserError, TData>({
    queryKey: queryKeyFn({ path: '/user', operationId: 'getUser', variables }),
    queryFn: ({ signal }) => fetchGetUser({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetVoiceActorsQueryParams = {
  /**
   * Only voice_actors where data.id matches one of the array values are returned.
   */
  ids?: number[]
  /**
   * Only voice_actors updated after this time are returned.
   *
   * @format date-time
   */
  updated_after?: string
}

export type GetVoiceActorsError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetVoiceActorsVariables = {
  queryParams?: GetVoiceActorsQueryParams
} & Context['fetcherOptions']

/**
 * Returns a collection of all voice actors, ordered by ascending created_at, 500 at a time.
 */
export const fetchGetVoiceActors = (variables: GetVoiceActorsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.VoiceActors,
    GetVoiceActorsError,
    undefined,
    object,
    GetVoiceActorsQueryParams,
    object
  >({
    url: '/voice_actors',
    method: 'get',
    ...variables,
    signal,
  })

/**
 * Returns a collection of all voice actors, ordered by ascending created_at, 500 at a time.
 */
export const useGetVoiceActors = <TData = Schemas.VoiceActors>(
  variables: GetVoiceActorsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.VoiceActors, GetVoiceActorsError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.VoiceActors, GetVoiceActorsError, TData>({
    queryKey: queryKeyFn({ path: '/voice_actors', operationId: 'getVoiceActors', variables }),
    queryFn: ({ signal }) => fetchGetVoiceActors({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type GetVoiceActorPathParams = {
  /**
   * ID of the resource
   */
  id: number
}

export type GetVoiceActorError = Fetcher.ErrorWrapper<
  | {
      status: 401
      payload: Responses.Unauthorized
    }
  | {
      status: 422
      payload: Responses.UnprocessableEntity
    }
>

export type GetVoiceActorVariables = {
  pathParams: GetVoiceActorPathParams
} & Context['fetcherOptions']

/**
 * Retrieves a specific voice actor by its id.
 */
export const fetchGetVoiceActor = (variables: GetVoiceActorVariables, signal?: AbortSignal) =>
  fetch<Schemas.VoiceActor, GetVoiceActorError, undefined, object, object, GetVoiceActorPathParams>(
    {
      url: '/voice_actors/{id}',
      method: 'get',
      ...variables,
      signal,
    },
  )

/**
 * Retrieves a specific voice actor by its id.
 */
export const useGetVoiceActor = <TData = Schemas.VoiceActor>(
  variables: GetVoiceActorVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.VoiceActor, GetVoiceActorError, TData>,
    'queryKey' | 'queryFn'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useContext(options)
  return reactQuery.useQuery<Schemas.VoiceActor, GetVoiceActorError, TData>({
    queryKey: queryKeyFn({ path: '/voice_actors/{id}', operationId: 'getVoiceActor', variables }),
    queryFn: ({ signal }) => fetchGetVoiceActor({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type QueryOperation =
  | {
      path: '/assignments'
      operationId: 'getAssignments'
      variables: GetAssignmentsVariables
    }
  | {
      path: '/assignments/{id}'
      operationId: 'getAssignment'
      variables: GetAssignmentVariables
    }
  | {
      path: '/level_progressions'
      operationId: 'getLevelProgressions'
      variables: GetLevelProgressionsVariables
    }
  | {
      path: '/level_progressions/{id}'
      operationId: 'getLevelProgression'
      variables: GetLevelProgressionVariables
    }
  | {
      path: '/resets'
      operationId: 'getResets'
      variables: GetResetsVariables
    }
  | {
      path: '/resets/{id}'
      operationId: 'getReset'
      variables: GetResetVariables
    }
  | {
      path: '/reviews'
      operationId: 'getReviews'
      variables: GetReviewsVariables
    }
  | {
      path: '/reviews/{id}'
      operationId: 'getReview'
      variables: GetReviewVariables
    }
  | {
      path: '/review_statistics'
      operationId: 'getReviewStatistics'
      variables: GetReviewStatisticsVariables
    }
  | {
      path: '/review_statistics/{id}'
      operationId: 'getReviewStatistic'
      variables: GetReviewStatisticVariables
    }
  | {
      path: '/spaced_repetition_systems'
      operationId: 'getSpacedRepetitionSystems'
      variables: GetSpacedRepetitionSystemsVariables
    }
  | {
      path: '/spaced_repetition_systems/{id}'
      operationId: 'getSpacedRepetitionSystem'
      variables: GetSpacedRepetitionSystemVariables
    }
  | {
      path: '/study_materials'
      operationId: 'getStudyMaterials'
      variables: GetStudyMaterialsVariables
    }
  | {
      path: '/study_materials/{id}'
      operationId: 'getStudyMaterial'
      variables: GetStudyMaterialVariables
    }
  | {
      path: '/subjects'
      operationId: 'getSubjects'
      variables: GetSubjectsVariables
    }
  | {
      path: '/subjects/{id}'
      operationId: 'getSubject'
      variables: GetSubjectVariables
    }
  | {
      path: '/summary'
      operationId: 'getSummary'
      variables: GetSummaryVariables
    }
  | {
      path: '/user'
      operationId: 'getUser'
      variables: GetUserVariables
    }
  | {
      path: '/voice_actors'
      operationId: 'getVoiceActors'
      variables: GetVoiceActorsVariables
    }
  | {
      path: '/voice_actors/{id}'
      operationId: 'getVoiceActor'
      variables: GetVoiceActorVariables
    }
